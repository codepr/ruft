use futures::{future, prelude::*};
use rand::prelude::*;
use std::{
    io,
    net::{IpAddr, SocketAddr},
};
use tarpc::{
    context,
    serde::{Deserialize, Serialize},
    server::{self, Channel, Incoming},
    tokio_serde::formats::Json,
};

#[derive(Clone)]
enum State {
    Follower,
    Candiate,
    Leader,
}

/// RequestVote call as described in Raft paper, it carries:
///
/// - the candidate's term
/// - the candidate's id
/// - the index of the candidate's last log entry
/// - the term of the candidate's last log entry
#[derive(Debug, Serialize, Deserialize)]
struct RequestVote {
    // Candidate's term
    term: i32,
    // Candidate's identifier
    candidate_id: String,
    // Index of the candidate's last log entry
    last_log_index: i32,
    // Term of the candidate's last log entry
    last_log_term: i32,
}

/// RequestVoteReply contains the current term for candidate to update, and a bool indication of
/// received vote
#[derive(Debug, Serialize, Deserialize)]
struct RequestVoteReply {
    // Current term for candidate to update itself
    term: i32,
    // True means candidate received vote
    vote_granted: bool,
}

/// AppendEntries call, contains the current term for the candidate and the Id of the leader node
#[derive(Debug, Serialize, Deserialize)]
struct AppendEntries {
    // Current term of the requesting node
    term: i32,
    // Leader ID
    leader_id: String,
}

/// AppendEntriesReply call, contains the current term for candidate and a bool indication of
/// received vote
#[derive(Debug, Serialize, Deserialize)]
struct AppendEntriesReply {
    // Current term for candidate to update itself
    term: i32,
    // True means candidate received vote
    success: bool,
}

#[tarpc::service]
trait Raft {
    async fn request_vote(r: RequestVote) -> RequestVoteReply;
    async fn append_entries(a: AppendEntries) -> AppendEntriesReply;
}

#[derive(Clone)]
struct LogEntry {
    // Current term of the command being issued
    term: i32,
    // The actual command to be applied to the state machine
    command: String,
}

/// The state machine to manage the state of a single node, can assume 3 different states:
///
/// - CANDIDATE
/// - LEADER
/// - FOLLOWER
#[derive(Clone)]
struct RaftMachine {
    // Identifier of the current node on the cluster
    id: String,
    // Latest term server has seen, initialized to 0 on first boot, increases
    // monotonically
    current_term: i32,
    // Candidate Id that received vote in the current term or nil if none
    voted_for: String,
    // Log entries; each entry contains command for state machine, and term
    // when entry was received by leader, first index is 1
    log: Vec<LogEntry>,
    // Index of the highest log entry known to be commited, initialized to 0,
    // increases monotonically
    commit_index: i32,
    // Index of the highest log entry applied to state machine, initialized to
    // 0, increases monotonically
    last_applied: i32,
    // State of the machine, can be either CANDIDATE, FOLLOWER or LEADER
    state: State,
    // Election timer timeout
    election_timeout: i64,
    // Last received heartbeat from leader
    latest_heartbeat: i64,
}

#[tarpc::server]
impl Raft for RaftMachine {
    async fn request_vote(self, _: context::Context, r: RequestVote) -> RequestVoteReply {
        RequestVoteReply {
            term: 0,
            vote_granted: false,
        }
    }

    async fn append_entries(self, _: context::Context, a: AppendEntries) -> AppendEntriesReply {
        AppendEntriesReply {
            term: 0,
            success: false,
        }
    }
}

impl RaftMachine {
    pub fn new(addr: String) -> Self {
        Self {
            id: addr.clone(),
            current_term: 0,
            voted_for: "".into(),
            log: Vec::new(),
            commit_index: 0,
            last_applied: 0,
            state: State::Follower,
            election_timeout: rand::thread_rng().gen_range(150..300),
            latest_heartbeat: 0,
        }
    }
}

pub async fn run(addr: &str) -> io::Result<()> {
    let mut listener = tarpc::serde_transport::tcp::listen(addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = RaftMachine::new(addr.into());
            channel.requests().execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
    Ok(())
}
