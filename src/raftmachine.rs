use futures::{future, prelude::*};
use rand::prelude::*;
use std::collections::HashMap;
use std::sync::Arc;
use std::{
    io,
    net::{IpAddr, SocketAddr},
};
use tarpc::{
    client, context,
    serde::{Deserialize, Serialize},
    server::{self, Channel, Incoming},
    tokio_serde::formats::Json,
};

#[derive(Clone)]
enum State {
    Follower,
    Candiate,
    Leader,
}

/// RequestVote call as described in Raft paper, it carries:
///
/// - the candidate's term
/// - the candidate's id
/// - the index of the candidate's last log entry
/// - the term of the candidate's last log entry
#[derive(Debug, Serialize, Deserialize)]
struct RequestVote {
    // Candidate's term
    term: i32,
    // Candidate's identifier
    candidate_id: String,
    // Index of the candidate's last log entry
    last_log_index: i32,
    // Term of the candidate's last log entry
    last_log_term: i32,
}

/// RequestVoteReply contains the current term for candidate to update, and a bool indication of
/// received vote
#[derive(Debug, Serialize, Deserialize)]
struct RequestVoteReply {
    // Current term for candidate to update itself
    term: i32,
    // True means candidate received vote
    vote_granted: bool,
}

/// AppendEntries call, contains the current term for the candidate and the Id of the leader node
#[derive(Debug, Serialize, Deserialize)]
struct AppendEntries {
    // Current term of the requesting node
    term: i32,
    // Leader ID
    leader_id: String,
}

/// AppendEntriesReply call, contains the current term for candidate and a bool indication of
/// received vote
#[derive(Debug, Serialize, Deserialize)]
struct AppendEntriesReply {
    // Current term for candidate to update itself
    term: i32,
    // True means candidate received vote
    success: bool,
}

#[tarpc::service]
trait Raft {
    async fn request_vote(r: RequestVote) -> RequestVoteReply;
    async fn append_entries(a: AppendEntries) -> AppendEntriesReply;
}

#[derive(Clone)]
struct LogEntry {
    // Current term of the command being issued
    term: i32,
    // The actual command to be applied to the state machine
    command: String,
}

/// The state machine to manage the state of a single node, can assume 3 different states:
///
/// - CANDIDATE
/// - LEADER
/// - FOLLOWER
#[derive(Clone)]
struct RaftMachine {
    // Identifier of the current node on the cluster
    id: String,
    // Latest term server has seen, initialized to 0 on first boot, increases
    // monotonically
    current_term: i32,
    // Candidate Id that received vote in the current term or nil if none
    voted_for: String,
    // Log entries; each entry contains command for state machine, and term
    // when entry was received by leader, first index is 1
    log: Vec<LogEntry>,
    // Index of the highest log entry known to be commited, initialized to 0,
    // increases monotonically
    commit_index: i32,
    // Index of the highest log entry applied to state machine, initialized to
    // 0, increases monotonically
    last_applied: i32,
    // State of the machine, can be either CANDIDATE, FOLLOWER or LEADER
    state: State,
    // Election timer timeout
    election_timeout: i64,
    // Last received heartbeat from leader
    latest_heartbeat: i64,
    // Cluster reference to all nodes
    cluster: Arc<RaftCluster>,
}

#[tarpc::server]
impl Raft for RaftMachine {
    async fn request_vote(self, _: context::Context, r: RequestVote) -> RequestVoteReply {
        RequestVoteReply {
            term: 0,
            vote_granted: false,
        }
    }

    async fn append_entries(self, _: context::Context, a: AppendEntries) -> AppendEntriesReply {
        AppendEntriesReply {
            term: 0,
            success: false,
        }
    }
}

impl RaftMachine {
    pub fn new(cluster: Arc<RaftCluster>, addr: String) -> Self {
        Self {
            id: addr.clone(),
            current_term: 0,
            voted_for: "".into(),
            log: Vec::new(),
            commit_index: 0,
            last_applied: 0,
            state: State::Follower,
            election_timeout: rand::thread_rng().gen_range(150..300),
            latest_heartbeat: 0,
            cluster: cluster,
        }
    }
}

pub struct RaftCluster {
    nodes: HashMap<String, RaftClient>,
}

impl RaftCluster {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
        }
    }

    pub async fn connect(&mut self, addr: &str) -> io::Result<()> {
        let mut transport = tarpc::serde_transport::tcp::connect(addr, Json::default);
        transport.config_mut().max_frame_length(usize::MAX);

        // RaftClient is generated by the service attribute. It has a constructor `new` that takes a
        // config and any Transport as input.
        let client = RaftClient::new(client::Config::default(), transport.await?).spawn()?;
        self.nodes.insert(addr.into(), client);
        Ok(())
    }

    pub async fn start(&mut self, peers: Vec<String>) -> io::Result<()> {
        for peer in peers.iter() {
            self.connect(peer).await?;
        }
        Ok(())
    }
}

pub async fn run(cluster: Arc<RaftCluster>, addr: &str) -> io::Result<()> {
    let mut listener = tarpc::serde_transport::tcp::listen(addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    // let server = server::BaseChannel::with_defaults(listener);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let c = cluster.clone();
            let server = RaftMachine::new(c, addr.into());
            channel.requests().execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
    Ok(())
}
